#ifndef __SoDaSNA_Top__
#define __SoDaSNA_Top__
/*
  Copyright (c) 2012, Matthew H. Reilly (kb1vc)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
   @file
   Subclass of SoDaRadioFrame, which is generated by wxFormBuilder.
*/

#include "SoDaSNA_GUI.h"
#include "GuiParams.hxx"
#include "SNAListenerThread.hxx"
#include "../src/UDSockets.hxx"
#include "../src/Command.hxx"
#include "../src/Debug.hxx"
#include <map>
#include <fstream>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/format.hpp>
#include "xyplot.hxx"
#include <wx/wx.h>
#include <wx/string.h>
#include <wx/wxchar.h>
#include <wx/thread.h>

namespace SoDaSNA_GUI {

  class CalibrateDialog;

  /**
   * The SoDaSNA object
   *
   * The SoDaSNA program provides a wxWidgets based GUI to control
   * the SoDa Scalar Network Analyzer SDR control program. SoDaSNA is partitioned into
   * three major components
   *
   * @li The Application object defined in SoDaSNA_App that launches the 
   * main GUI control thread defined by SoDaSNA_Top
   * @li the SNAListenener object that connects to the SoDa::UI thread.
   * @li the wxWidgets GUI event loop that dispatches user requests
   * through the SoDaSNA_Top thread.
   */
  class SoDaSNA_Top : 
    public SoDaSNAFrame, 
    public SoDa::Debug,
    public SoDaRadio_GUI::XYPlotClient 
  {
    friend class SoDaRadio_GUI::XYPlot;
    
  protected:
    // Handlers for SoDaSNAFrame events.
    void OnOpenConfig( wxCommandEvent& event );
    void OnSaveConfig( wxCommandEvent& event );
    void OnSaveConfigAs( wxCommandEvent& event );
    void OnCalibrate( wxCommandEvent & event );     

    void OnClose( wxCommandEvent& event );
    void OnQuit( wxCommandEvent& event );    

    void OnAbout( wxCommandEvent& event );

    void OnUserGuide( wxCommandEvent& event );

    void OnFreqEnter( wxCommandEvent& event );
    void OnFreqRangeSel( wxCommandEvent& event );
    void OnFreqEnter( wxMouseEvent& event );

    void OnOutputPowerSel( wxScrollEvent& event );

    void OnSweepSpeed( wxCommandEvent& event );    
    void OnSweepControl( wxCommandEvent & event); 

    // the save dialog
    wxFileDialog * save_config_dialog;
    wxString save_config_file_name;

    // message handlers
    void OnUpdateSNAPlot(wxCommandEvent & event); 

    double multFromUnitsString(wxChoice * widg) {
      int sel = widg->GetSelection();
      std::string units(widg->GetString(sel).mb_str());

      if(units == "Hz") return 1.0; 
      if(units == "kHz") return 1.0e3;
      if(units == "MHz") return 1.0e6;
      if(units == "GHz") return 1.0e9;
      return 1.0; 
    }

    double unitsFromSpan(wxChoice * widg) {
      int sel = widg->GetSelection();
      std::string span(widg->GetString(sel).mb_str());
      
      if(span == "1") return 1.0;
      if(span == "10") return 10.0;
      if(span == "100") return 100.0; 
      if(span == "2") return 2.0;
      if(span == "20") return 20.0;
      if(span == "200") return 200.0; 
      if(span == "5") return 5.0;
      if(span == "50") return 50.0;
      if(span == "500") return 500.0; 
      return 1.0;
    }

    void updateXYPlot();
    void GetFreqSettings();    

  private:
    double min_span, max_span; 
    double min_cfreq, max_cfreq; 

    double display_cfreq; 
    double display_start_freq; 
    double display_end_freq; 
    
    double display_min_gain;
    double display_max_gain; 

  public:
    /** Constructor */
    SoDaSNA_Top( SoDa::SNAGuiParams & parms, wxWindow* parent );

    void UpdatePlotAxes();
    
    // calibration stuff
    void StartPassThroughCalibration(CalibrateDialog * dlg);
    void StartOpenCalibration(CalibrateDialog * dlg);
    void CompletePassThroughCalibration(CalibrateDialog * dlg);
    void CompleteOpenCalibration(CalibrateDialog * dlg);

    void postErrorText(const std::string & errmsg); 
    void clearErrorText();

    double sweep_start_freq;
    double sweep_end_freq;
    double sweep_step; 

    SoDa::UD::ClientSocket * GetCmdQueue() { return soda_radio; }

    void setSDRVersion(char * buf) {
      wxMutexLocker lock(ctrl_mutex);
      strncpy(SDR_version_string, buf, 64);
    }
  
    void SaveConfig(const wxString & fname);
    bool LoadConfig(const wxString & fname);
    void CreateDefaultConfig(boost::property_tree::ptree * config_tree);

    void SetConfigFileName(const wxString & fname); 
    bool CreateSpectrumTrace(double * freqs, float * powers, unsigned int len);

    wxString radio_modelname; ///< The type of radio (n200, b200, x300...)
    
    enum MSG_ID { MSG_UPDATE_MODELNAME, MSG_SNA_SCAN_REPORT, MSG_SNA_SCAN_END };
    enum SWEEP_MODE { CONTINUOUS_SWEEP, SINGLE_SWEEP, NO_SWEEP }; 
    SWEEP_MODE sweep_mode;

    // initiate a sweep operation. 
    void doSweep(bool initial_sweep); 
    
    enum MEAS_MODE { CAL_OPEN, CAL_PASS, NORMAL, IGNORE }; 

    MEAS_MODE setMeasMode(MEAS_MODE nmode) {
      MEAS_MODE old = measurement_mode; 
      measurement_mode = nmode; 
      return old; 
    }

    void commitCalibration() {
      // move the new calibration settings into the 
      // active calibration vector. 
      std::cerr << "Write the commit cal routine!" << std::endl; 
    }

    void setRadioName(const wxString & mname) {
      wxMutexLocker lock(ctrl_mutex);
      radio_modelname = wxT("SoDa Radio Scalar Network Analyzer ") + mname; 
      wxCommandEvent event(wxEVT_COMMAND_MENU_SELECTED,
			   SoDaSNA_Top::MSG_UPDATE_MODELNAME);
      pendEvent(event); 
    }

    void createUpdateEvent(double freq, double magsq) {
      // already mutually exclusive? Probably not. 
      wxMutexLocker lock(ctrl_mutex);      
      measurements.push(std::pair<double, double>(freq, magsq));
    }

    void createScanEndEvent() {
      wxCommandEvent event(wxEVT_COMMAND_MENU_SELECTED,
			   SoDaSNA_Top::MSG_SNA_SCAN_END);
      pendEvent(event); 
    }
			   
    void OnScanEnd(wxCommandEvent & event) {
      wxMutexLocker lock(ctrl_mutex);            
      while(!measurements.empty()) {
	std::pair<double, double> pt = measurements.front();
	measurements.pop();
	std::cout << boost::format("M %g %g\n") % pt.first % pt.second;
      }

      doSweep(false);
    }

    void OnScanReport(wxCommandEvent & event) {

    }
    
    void OnUpdateModelName(wxCommandEvent & event) {
      this->SetTitle(radio_modelname); 
    }

    void OnSampleUpdate(wxCommandEvent & event);


    void pendEvent(wxCommandEvent & event) {
      GetEventHandler()->AddPendingEvent(event);
    }

    // start the listener thread
    void startListener() {
      // now launch it.
      debugMsg("Launching listener thread.");
      if(listener->Create() != wxTHREAD_NO_ERROR) {
	wxLogError(wxT("Couldn't create radio listener thread...")); 
      }

      debugMsg("Running listener thread.");
      listener->Run(); 
      
      // ask 
      SoDa::Command ncmd(SoDa::Command::GET, SoDa::Command::HWMB_REP);
      sendMsg(&ncmd);
      debugMsg("sent model ID request.\n");
    }

    // complete configuration
    void configureRadio(SoDa::SNAGuiParams & params);

  private:
    char SDR_version_string[64];

    unsigned int debug_mode;
    MEAS_MODE measurement_mode; 
  
    SoDaRadio_GUI::XYPlot * pgram_plot; ///< the S21 magnitude display
    SoDaRadio_GUI::XYPlot::Trace * pgram_trace;  ///< pointer to the current trace

    // Comm socket to SoDa radio server.
    SoDa::UD::ClientSocket * soda_radio;

    void sendMsg(const SoDa::Command * cmd) {
      std::cerr << "Sending a message" << std::endl; 
      std::cerr << "Message [" << cmd << "]" << std::endl; 
      soda_radio->put(cmd, sizeof(SoDa::Command));
    }

    // the listener thread
    SNAListenerThread * listener;

    // the mutex used to synchronize access between the GUI
    // thread and the radio listener thread
    wxMutex ctrl_mutex;

    // queue of measurements to be drawn on the display
    std::queue<std::pair<double, double> > measurements;

    // configuration info
    boost::property_tree::ptree * config_tree_alloc, * config_tree; 

  };

  class AboutDialog : public t_AboutDialog {
  public:
    AboutDialog(wxWindow * parent, char * SDR_version_string) : t_AboutDialog(parent) {
      // setup the gui version string
      std::string guiv = (boost::format("GUI Version: %s SVN %s") % PACKAGE_VERSION % SVN_VERSION).str();
      wxString wxver(guiv.c_str(), wxConvUTF8);
      m_GUIVersion->SetLabel(wxver);
      std::string sdrv = (boost::format("SDR Version: %s") % SDR_version_string).str();
      wxString wxsdr(sdrv.c_str(), wxConvUTF8);
      m_SDRVersion->SetLabel(wxsdr); 
    }
    void OnAboutOK( wxCommandEvent & event); 
  
  };

  class NewConfigDialog : public t_NewConfigDialog {
  public:
    NewConfigDialog(wxWindow * parent, SoDaSNA_Top * _radio) : t_NewConfigDialog(parent) {
      radio = _radio; 
    }
    void OnCreateConfigDefault( wxCommandEvent & event);
    void OnDismissCreateConfigDefault( wxCommandEvent & event);
    SoDaSNA_Top * radio; 
  };
  
  class CalibrateDialog : public t_CalibrateDialog {
  public:
    CalibrateDialog(wxWindow * parent, SoDaSNA_Top * _sna) : t_CalibrateDialog(parent) {
      sna = _sna; 
      cur_step = 0; 
      printCalStep(cur_step); 
      m_CalStatus->Clear();
      m_SaveCal->Disable();
    }

    void printCalStep(int stepnum) {
      wxString cal_prompt; 
      wxString done_prompt = wxT("Press \"Done\" when action is complete.");
      bool enable_done = true; 
      switch(stepnum) {
      case 0: 
	cal_prompt = wxT("\nConnect 20dB attenuator to RX antenna port.\n");
	break; 
      case 1: 
	cal_prompt = wxT("\nConnect optional attenuator to TX antenna port.\n");
	break; 
      case 2: 
	cal_prompt = wxT("Connect pass-through cable from TX attenuator/port\nto RX attenuator.\n");
	break; 
      case 3: 
      case 5:
	cal_prompt = wxT("\nWait for callibration sweep to complete.\n");
	enable_done = false;
	break; 
      case 4: 
	cal_prompt = wxT("\nDisconnect pass-through cable.\n");	
	break; 
      case 6: 
	cal_prompt = wxT("Calibration is complete.\nPress \"Save Calibration\" to exit,\nor \"Cancel\" to return to previous settings.");
	enable_done = false;	
	m_SaveCal->Enable();
	break; 
      }

      m_CalStepTxt->SetLabel(cal_prompt);

      if(enable_done) {
	m_CalStepPrompt2->SetLabel(done_prompt);
	m_CalStepDone->Enable();
      }
      else {
	m_CalStepPrompt2->SetLabel(wxT(""));
	m_CalStepDone->Disable();
      }
    }

    void OnCalStepDone(wxCommandEvent & event) {
      cur_step++; 
      printCalStep(cur_step); 
      if(cur_step == 3) {
	sna->StartPassThroughCalibration(this);
      }
      if(cur_step == 5) {
	sna->StartOpenCalibration(this);
      }

    }

    void CompleteStep() {
      cur_step++; 
      printCalStep(cur_step);
    }

    void AppendProgressMsg(const wxString & str) {
      (*m_CalStatus) << str << wxT("\n"); 
      // m_CalStatus->AppendText(str);
    }

    void OnAbortCalibration( wxCommandEvent & event) {
      if(IsModal()) EndModal(wxID_CANCEL);
      else {
	SetReturnCode(wxID_CANCEL);
	this->Show(false); 
      }
    }

    void OnSaveCalibration( wxCommandEvent & event) {
      if(IsModal()) EndModal(wxID_OK);
      else {
	SetReturnCode(wxID_OK);
	this->Show(false); 
      }
    }

    SoDaSNA_Top * sna; 
    int cur_step; 
  }; 

}
#endif // __SoDaSNA_Top__
